---
layout: post
title: Binding to Bean Validations
date: '2014-11-14T13:28:00.002-08:00'
author: SÃ¸ren Kyndi-Wiuff
tags: 
modified_time: '2014-11-15T11:38:25.402-08:00'
blogger_id: tag:blogger.com,1999:blog-755334831791293490.post-4709025909462522730
blogger_orig_url: http://blog.kyuff.dk/2014/11/binding-to-bean-validations.html
---

<p>Currently I am working on a JavaFX Application. As it goes with most UI applications there needs to be input validation. Doing that on the server is a solved problem with the <a href="http://beanvalidation.org">Bean Validation api</a>. It is easy to use and well integrated in the JEE technology stack.  </p><p>It is not the same story in the user interface! </p><p>In most cases you want to connect the error with a specific interface element. This could be done by displaying an error text next to the field or change the fields background color . All in order to make it easy for the user to find the place where something needs to be fixed. </p><p>To connect an UI element with a specific violation source on an entity, the ConstraintViolation interface provides the getPropertyPath() method. This returns a Path which basically boils down to a string formatted after a bean style convention - ie parent.name.  </p><p>A naive approach to bind the violation to the UI elements would be something similar to: </p><pre>  <code class="language-java"><br />void handleViolation(ConstraintViolation&lt;?&gt; violation) {<br />   String path = violation.getPropertyPath().toString();<br />   String message = violation.getMessage();<br />   if( "parent".equals(path) ) {<br />      showParentError(message);<br />   } else if( "parent.name".equals(path) ) {<br />      showParentNameError(message);<br />   } else {<br />      showDefaultError(message);<br />   }<br />}<br />  </code><br /></pre><p>The problem with this code is that you don't have any compiler support. When you refactor the entity, the code will break silently. We need a better way to do this. One that uses the strong typing of the language and remains flexible to do the binding. </p><pre>  <code class="language-java"><br />  void bind(errorHandler, Entity::getField() );<br />  </code><br /></pre><p>Fortunately Java 8 brings <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html">Method References</a> that allows for this syntax. Now we can create an api like this:</p><pre>  <code class="language-java"><br />ValidationBinder&lt;Person&gt; v = new BeanValidator&lt;&gt;(Person.class)<br />  // simple binding - a normal usecase<br />  .bind(Handlers.messages(phoneErrors::setText), Person::getPhone)<br />  // multi binding with chained handlers<br />  .bind(Handlers.messages(nameErrors::setText).andThen(<br />        Handlers.styling(nameBox, "error"),<br />        pojo -&gt; {<br />          pojo.getFirstName();<br />          pojo.getLastName();<br />       }<br />  )<br />  // binding to fields in the entity object graph<br />  .bind(Handlers.messages(carErrors::setText), pojo -&gt; {<br />     pojo.getCar().getEngine();<br />     pojo.getCar().getPrice();<br />  });<br /></code><br /></pre><p>The signature of the bind method is </p><pre>  <code class="language-java"><br />ValidationBinder&lt;T&gt; bind(Consumer&lt;List&lt;String&gt;&gt; handler, Consumer&lt;T&gt; binder);<br /></t></list></t></code></pre><p>The first argument is the lambda that will take the possible errors a validation of an entity have produced on the fields bound in the second argument. Both arguments use the Java 8 function interfaces. This gives a certain convenience as these contains solid default methods allowing for the chaining seen in the andThen call. </p><p>An example of creating a new handler: </p><pre>  <code class="language-java"><br />Consumer&lt;List&lt;String&gt;&gt; messages(Consumer&lt;String&gt; consumer) {<br />        return (messages) -&gt; {<br />            String message = String.join("\n", messages);<br />            consumer.accept(message);<br />        };<br />    }<br /></code><br /></pre><p>This approach gives us some benefits: <ul>  <li>Refactoring preserves validation handling</li>  <li>The API is flexible - you just need a lambda to bind error messages</li>  <li>It is possible to listen to the same violation source from several handlers</li>  <li>Nested entities can be bound</li></ul><p>There is some drawbacks though:</p><ul>  <li>The BeanValidator uses <a href="https://github.com/cglib/cglib">cglib</a> to create the recording binder. That can be an issue in some environment that uses a SecurityManager</li>  <li>Recording is done by calling methods on the entity. These methods are converted to bean style naming which  - hopefully -  matches the class field that holds the Constraint annotation. If that is not the case, the BeanValidator won't work</li></ul></p><p>In conclusion I believe the benefits of this solution far outweighs the drawbacks. It is simple to create the binding between the constraints and the handler that can show them to a user. The drawbacks are easily circumvented by using Java conventions and best practices. </p><p>Check out the code in my GitHub project <a href="https://github.com/kyuff/validation-binder">validation-binder</a></p>