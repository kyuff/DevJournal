---
layout: post
title: Database Semaphores
date: '2014-11-23T12:55:00.000-08:00'
author: SÃ¸ren Kyndi-Wiuff
tags: 
modified_time: '2014-11-23T13:05:43.055-08:00'
blogger_id: tag:blogger.com,1999:blog-755334831791293490.post-7236561894827177371
blogger_orig_url: http://blog.kyuff.dk/2014/11/database-semaphores.html
---

<strong>The Challenge</strong><p>How to run EJB TimerService in a multi-node non-cluster JEE7 Environment?<br />Using the EJB Timer Service is a convenient way to produce scheduled tasks. Either through the <a href="https://docs.oracle.com/javaee/7/api/javax/ejb/TimerService.html">explicit api</a> or using the <a href="https://docs.oracle.com/javaee/7/api/javax/ejb/Schedule.html">automatic timers with the annotation api</a>. </p><p>If the environment was clustered, the EJB implementation might guarantee a single execution of the timeout methods. Clustering introduces other challenges though, and it really is depending on which Application server is used. </p><p>How do we handle that each node in the farm will execute the timered methods? </p><p><strong>Solution 1: Special Node</strong></p><p>One solution would be to promote a node to be special. This node would have the responsibility to perform the code that fulfills the business needs. The other nodes would recognize they are not promoted to being special and avoid performing the code. One way to do this, could for instance be to have a system property in the JVM or an environment variable that denotes the responsibility to be timer executioner. </p><p>The solution have several drawbacks though: </p><p><ul><li>Configuration complexity - The nodes in the farm is no longer equal. One needs to be configured differently</li><li>Operations - The special node have a greater responsibility and operations must be ensured before the other nodes</li><li>Scalability - When the business needs increases, chances are the special node cannot keep up. The need arises for one more special node, further adding to the complexity</li></ul><p><strong>Solution 2: Database Semaphore</strong></p><p>In concurrent programming a <a href="http://en.wikipedia.org/wiki/Semaphore_(programming)">semaphore</a> are used to restrict access to a common resource. In this case the resource is the right to perform the business logic. By using a semaphore it would be possible to implement a strategy where each node in the farm attempts to do the business logic as long as it's able to attain the semaphore lock. </p><p>In fact, this is <a href="http://quartz-scheduler.org/api/2.1.7/org/quartz/impl/jdbcjobstore/DBSemaphore.html">one of the strategies</a> scheduling frameworks like <a href="http://quartz-scheduler.org/">Quartz</a> uses when trying to do work in a concurrent environment. </p><p>For a simple EJB Timer it is really easy to do. Create an Entity and corresponding database schema: </p><pre><code class="language-java"><br />@Entity<br />@Table(name = "semaphore")<br />public class SemaphoreEntity {<br /><br />    @Id<br />    @Enumerated(EnumType.STRING)<br />    Semaphore id;<br /><br />    public Semaphore getId() {<br />        return id;<br />    }<br /><br />    public void setId(Semaphore id) {<br />        this.id = id;<br />    }<br />}<br /></code></pre><p>And an Enum where the above Entity is pre-filled with the same values in the database. <pre><code class="language-java"><br />public enum Semaphore {<br />    BUSINESS,<br />    BLACKOPS<br />}<br /></code></pre><p>Now it is easy to get a lock for the task at hand</p><pre><code class="language-java"><br />try {<br />   entityManager.find(SemaphoreEntity.class, <br />                   Semaphore.BUSINESS, <br />                   LockModeType.PESSIMISTIC_WRITE);<br />   System.out.println("Perform Business Work here");<br />} catch (PersistenceException e) {<br />   System.out.println("Accept you are not the Special Node");<br />}<br /></code></pre><p>As with any solution there are a few drawbacks to this approach: </p><ul><li>The database is the constraint of the operation. The ability to scale out is limited by the database.</li><li>There are faster approaches, although for most cases this is plenty fast</li><li>Using a pessimistic write lock works slightly different depending on JPA implementation and JDBC driver. For instance does the postgresql driver require a timeout of 0 in order for this to work</li></ul><p>Check out the proof of concept code on <a href="https://github.com/kyuff/database-semaphore/tree/master">GitHub</a>.    