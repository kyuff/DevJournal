---
layout: post
title: JavaFX Code Structure
date: '2014-11-30T06:29:00.000-08:00'
author: SÃ¸ren Kyndi-Wiuff
tags: 
modified_time: '2014-11-30T06:29:58.822-08:00'
blogger_id: tag:blogger.com,1999:blog-755334831791293490.post-2766384499290629119
blogger_orig_url: http://blog.kyuff.dk/2014/11/javafx-code-structure.html
---

<p><a href="http://www.oracle.com/technetwork/java/javase/overview/javafx-overview-2158620.html">JavaFX</a> is Oracles attempt at a modern UI Framework for the Java Platform. Although it is better than Swing, it is far away from what it could have been. </p><p>One of many things JavaFX is missing is the testing story. </p><p>JavaFX have this seemingly cool feature called FXML. With it, you can write declarative XML code and easily let the runtime map it to code. Combine that with the UI tool SceneBuilder you have a convenient way to create complex interfaces. There is a catch though. FXML uses a concept of a controller, which is where you have your Java code. This controller can look something like this: </p> <pre><code class="language-java"><br /><br />public class PersonController {<br /><br />    @FXML<br />    Button button;<br />    @FXML<br />    TextField input;<br />    @FXML<br />    Label label;<br />// [...]<br />}<br /><br /></code></pre> <p>The FXMLLoader will do the boring work of initializing the UI nodes and bind them together after your instructions in the xml code. Practical and easy. Eventually you want to test your code. You have two approaches: Unit Tests or Automated UI Testing. For the latter you can use <a href="https://github.com/TestFX/TestFX">TestFX</a> or <a href="https://jemmy.java.net/JemmyFXGuide/jemmy-guide.html">JemmyFX</a>. Automated UI Testing is an expensive task which I won't go into detail with here since you probably want to be able to Unit Test the FXML controllers anyways. </p><p>But you can't! </p><pre><code class="language-java"><br />@RunWith(MockitoJUnitRunner.class)<br />public class PersonControllerTest {<br /><br />    PersonController controller;<br /><br />    @Mock<br />    Button button;<br /><br />    @Before<br />    public void setUp() throws Exception {<br />        controller = new PersonController();<br />        controller.button = button;<br />    }<br /><br />    @Test<br />    public void testInitialize() throws Exception {<br />        assertTrue(true);<br />    }<br />}<br /></code></pre>  <p>Running a simple test as <a href="https://github.com/kyuff/basefx/blob/master/samples/sample-presenter/src/test/java/dk/kyuff/basefx/samples/presenter/PersonControllerTest.java">the above</a> fails horribly with an <code>java.lang.IllegalStateException: Toolkit not initialized</code>. </p><p>I cannot believe that Oracle delivers a UI Framework that doesn't include its own automated UI test tool and a design that allows for easy unit testing of <strong>all</strong> code in the project. </p><p>So how to work around it? </p> <p>Although cumbersome and a bit annoying, the only way to achieve testability is to separate the JavaFX code from the presentation code. <a href="http://www.gwtproject.org/articles/mvp-architecture.html">GWT does something similar</a>, and even have API support for it with the way UI nodes all implement interfaces.  </p><p>It's a basic MVP structure and in that sense nothing new here. The Presenter defines it's view using basic types/properties, which allows it to be mocked in unit testing. Furthermore it ensures that the presenter focuses on <strong>what</strong> is needed instead of on <strong>how</strong> it should be done. A simple example of a view is this: </p><pre><code class="language-java"><br /><br />public class PersonPresenter implements Presenter&lt;PersonPresenter.View&GT; {<br /><br />    public static interface View extends Initializable {<br />        StringProperty getLabelText();<br />        StringProperty getButtonText();<br />        StringProperty getInputText();<br />        ObjectProperty&lt;EventHandler&lt;ActionEvent&gt;&gt; getOnAction();<br />    }<br /><br />    View view;<br /><br />    @Override<br />    public void initialize(View view) {<br />        this.view = view;<br /><br />        view.getLabelText().setValue("");<br />        view.getButtonText().setValue("Click here");<br />        view.getInputText().setValue("Type something here ...");<br /><br />        view.getOnAction().setValue(this::onButtonClicked);<br />    }<br /><br />    void onButtonClicked(ActionEvent event) {<br />        String inputText = view.getInputText().getValue();<br />        view.getLabelText().setValue(inputText);<br />        System.out.println("Updating label to: " + inputText);<br />    }<br />}<br /></code></pre><p>This implemented interface is very simple and mostly done so the view controller can call the initialize method on the presenter from it's own initialize method: </p><pre><code class="language-java"><br />public interface Presenter&lt;T&gt; {<br />    void initialize(T view);<br />}<br /></code></pre><p>By design the view controller is very simple. It should only expose the functionality the presenter requires and not contain any sort of logic. Since we cannot unit test it, it should be as light-weight and as little code as possible. </p><pre><code class="language-java"><br />public class PersonController implements PersonPresenter.View {<br />    @FXML<br />    Button button;<br />    @FXML<br />    TextField input;<br />    @FXML<br />    Label label;<br /><br />    Presenter&lt;PersonPresenter.View&gt; presenter;<br /><br />    @Override<br />    public void initialize(URL location, ResourceBundle resources) {<br />        presenter = ... // Construct the presenter or use injection<br />        presenter.initialize(this);<br />    }<br />    @Override<br />    public ObjectProperty&lt;EventHandler&lt;ActionEvent&gt;&gt; getOnAction() {<br />        return button.onActionProperty();<br />    }<br /><br />    @Override<br />    public StringProperty getLabelText() {<br />        return label.textProperty();<br />    }<br /><br /><br />    @Override<br />    public StringProperty getButtonText() {<br />        return button.textProperty();<br />    }<br /><br />    @Override<br />    public StringProperty getInputText() {<br />        return input.textProperty();<br />    }<br />}<br /></code></pre><p><p>You can view the code under the <a href="https://github.com/kyuff/basefx/tree/master/samples/sample-presenter">sample-presenter folder</a> in <a href="https://github.com/kyuff/basefx">this project</a> on GitHub. </p>    